<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="description" content="Slides for the CodeMash 2015 talk by Chandu Tennety and John Andrews">
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>A Bird's Eye View of ClojureScript</title>
    <link rel="stylesheet" href="css/reveal.min.css">
    <link rel="stylesheet" href="css/theme/neo.css" id="theme">
    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="lib/css/hemisu-light.css">
    <!-- If the query includes 'print-pdf', include the PDF print sheet -->
    <script>
      if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = 'css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
      }
    </script>
    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <h1>A Bird's Eye View of ClojureScript</h1>
          <h4>
            Chandu Tennety
          </h4>
          <p>
          {:github "tennety" :twitter "tennety"}
          </p>
          <br>
          <h4>
            John Andrews
          </h4>
          <p>
            {:github "jxa" :twitter "xandrews"}
          </p>
          <aside class="notes">
            Thank you for coming to this talk, we value your time and are
            excited that you chose to share it with us. I'm Chandu, I do app
            development at Neo, mostly using Rails and JavaScript. This is John
            Andrews.

            Hi I'm John, formerly of Neo. Currently I'm an application developer
            at LendingHome, an online mortgage marketplace. Most of my work is
            done in Ruby and Javascript, however I've been creating things with
            Clojure for several years.
            <!-- John introduces himself ><!-->

            ## Audience Interaction
            Before we jump in, we'd like to get a feel for how familiar you are
            with some of the things we're going to talk about. How many of you
            have heard of:
            * Birding?
            * Clojure?
            * ClojureScript?
            * d3? Mapping with d3?
            * React? Om?

            Well, John and I made a thing that uses some of these things. We
            had a lot of fun making it, and would like to talk about our
            experiences, and hopefully give you an overview of the technologies
            and techniques we used.
          </aside>
        </section>


        <section>
          <section>
            <h2>Motivation</h2>
            <div class="fragment">
              <img alt="map" src="images/map.gif"><br>
              <small><a href="http://press.princeton.edu/birds/arlott/warbler/images/map.gif" target="_blank">Source: Princeton University</a></small>
            </div>
            <aside class="notes" data-markdown>
              The thing we made is called Birdwave, and it's primarily a data
              visualization. The idea of Birdwave came to me partly because of
              an interest and a hobby that I have.

              ### Birding
              * Observing and identifying birds, visually and by ear.
              * Quiet and relaxing (when you need to get away from big crowds of technologists)
              * Closely tied with migratory patterns:
                - Migration seasons are peaks
                - Non-migratory birds are all you have in the off-season
              * Field guides
                - Beautiful illustrations, identifying characteristics
                - Show static maps of breeding areas during the year
            </aside>
          </section>
          <section>
            <h2>Motivation</h2>
            <div>
              <img width="100%" alt="map" src="images/map-specific.png"><br>
              <p>
                Yellow Warbler
                <object type="application/x-shockwave-flash" data="http://imagess3.enature.com/listen.swf" width="63" height="15" id="bd0363" style="visibility: visible;"><param name="flashvars" value="audio=bd0363"></object>
              </p>
              <p>
                Chestnut-sided Wabler
                <object type="application/x-shockwave-flash" data="http://imagess3.enature.com/listen.swf" width="63" height="15" id="bd0362" style="visibility: visible;"><param name="flashvars" value="audio=bd0362"></object>
              </p>
            </div>
            <aside class="notes" data-markdown>
              * Whimsical descriptions of songs:
                - Yellow warbler -- "sweet sweet sweet I'm so sweet"
                - Chestnut-sided warbler -- "pleased pleased pleased to meecha"
              * So I thought it'd be nice to plot bird migration data on a map, as it changes month-to-month.
              * Basically this...
            </aside>
          </section>
        </section>


        <section>
          <h2>Demo</h2>
          <video controls>
            <source src="images/birdwave-demo.mp4" type="video/mp4">
          </video>
        </section>


        <section>
          <section>
            <h2>Data for the App</h2>
            <h4 class="fragment"><a target="_blank" href="http://ebird.org/content/ebird/about/">eBird</a> data set</h4>
            <ul class="task-list">
              <li class="fragment">Data for 1 year for the US region</li>
              <li class="fragment">11 GB of tab-separated values</li>
              <li class="fragment">Over 1700 species</li>
            </ul>
            <aside class="notes" data-markdown>
              ### eBird
              * Collaboration between National Audubon Society and Cornell Lab of Ornithology
              * Gather bird sighting reports from all over the world (an incredible amount of data)
              * Have a very basic API, not good for trends
              * Data available for download free for academic use

              ## Audience Interaction
              * How much data do you think that was?
            </aside>
          </section>

          <section>
            <h2>Data for the App</h2>
            <h4>The need for an API</h4>
            <ul class="task-list">
              <li class="fragment">Safe, quick data import</li>
              <li class="fragment">Too much data to load at once</li>
              <li class="fragment">Dynamic nature of the app</li>
              <li class="fragment">d3 handles JSON requests</li>
            </ul>
            <aside class="notes" data-markdown>
              * There's way too much data to *not* load on demand
              * The event-driven nature of the app meant that it couldn't be
              modeled with a traditional request-response cycle. There needed to
              be an API capable of rendering tailored responses to different
              parameters.
              That's when John decided to use Clojure to build this API.
            </aside>
          </section>
        </section>


        <section>
          <section>
            <h2>Parsing the Data</h2>
            <h4>Clojure Syntax</h4>
            <video height="200" controls class="fragment">
              <source src="images/js-to-lisp-3.mp4" type="video/mp4">
            </video>

            <video height="200" controls class="fragment">
              <source src="images/clojure-defn.mp4" type="video/mp4">
            </video>

            <aside class="notes" data-markdown>
              * list processing
              * function position
              * macros
              * defines a function
              * point out the vector
              * lisp syntax with addition of richer data-type literals
            </aside>
          </section>


          <section>
            <h2>Parsing the Data</h2>
            <pre><code>
;; Clojure

(def fields
  [:sighting/guid                   ;; "GLOBAL UNIQUE IDENTIFIER"
   :taxon/order                     ;; "TAXONOMIC ORDER"
   nil                              ;; "CATEGORY"
   :taxon/common-name               ;; "COMMON NAME"
   :taxon/scientific-name           ;; "SCIENTIFIC NAME"
   :taxon/subspecies-common-name    ;; "SUBSPECIES COMMON NAME"
   :taxon/subspecies-scientific-name;; "SUBSPECIES SCIENTIFIC NAME"
   :sighting/count                  ;; "OBSERVATION COUNT" ;; x indicates uncounted
   ;; ...
   ])
            </code></pre>

            <aside class="notes" data-markdown>
              * the details of this aren't that important. Just need to ease you all into this whole clojure thing.
              * Our file is tab separated values
              * Records delimited by a newline
              * Def fields defines a var called fields which identifies
              * We split a line on tab characters and then compare to this vector
              * If there is a keyword in the same position then we extract that value into a hashmap with this keyword as its key
              * semicolons indicate comments
              * keywords begin with a colon and contain an optional namespace
            </aside>
          </section>

          <section>
            <h2>Parsing the Data</h2>
            <pre><code>
;; Clojure

(defn sighting-seq
  "Return a lazy sequence of lines from filename, transformed into sighting maps"
  [filename skip-rows nth-row]
  (->> (io/reader filename)
       (line-seq)
       (drop (or skip-rows 1))
       (take-nth nth-row)
       (map sighting)))
            </code></pre>

            <aside class="notes" data-markdown>
              * This example constructs a pipeline of data transformation steps
              * beginning with a lazy sequence of lines read from the file
              * each step is lazy
              * returning a lazy sequence means we can take 100 records, 1000, or all of them
              * and we'll never run out of memory because it only does the work on demand
              * the whole collection never exists in memory at the same time.
            </aside>
          </section>

          <section>
            <h2>Data Storage and Querying</h2>
            <h3>Datomic</h3>
            <img src="images/datomic.png">

            <aside class="notes" data-markdown>
              * Now that we have parsed our file into data structures we need some place to put them that's easily queried
              * We chose to use the database conceived by Clojure's author, Rich Hickey.
            </aside>
          </section>

          <section>
            <h2>Datomic</h2>
            <ul>
              <li>Schema</li>
              <li>Transactional</li>
              <li>History preserving</li>
              <li>Query language <em>is</em> Clojure data</li>
              <li>Results are Clojure data structures</li>
              <li>Query is executed in application server</li>
            </ul>

            <aside class="notes" data-markdown>
              * We didn't particularly need transactions or history for this application
              * but we were curious and wanted to experience using this new technology
              * and we liked the fact that query would scale horizontally with the application.
            </aside>
          </section>

          <section>
            <h2>Datomic</h2>
            <code><pre>
;; clojure

(q '[:find (sum ?count) (count ?e)
     :where
     [?t :taxon/order "2881"]
     [?e :sighting/taxon ?t]
     [?e :sighting/state "Ohio"]
     [?e :sighting/county "Sandusky"]
     [?e :sighting/count ?count]]
   (db conn))

;;=> [[540 108]]
            </pre></code>

            <aside class="notes" data-markdown>
              * Example of datomic query that finds the number of bald eagle sightings
              * And the total eagle count for Sandusky Ohio
              * Don't get into it... For flavor only.
              * Easy at first -- kept schema simple with a single entity per sighting
              * Slow import, leading to use of partial data set for dev
              * Talking reeeally slow... many hours.
              * But it was enough data to get started on a web service
            </aside>
          </section>
        </section>


        <section>
          <h2>Web Service</h2>
          <h3>Pedestal</h3>
          <ul>
            <li>Powerful middleware system</li>
            <li>Routing</li>
            <li>HTML Templating</li>
          </ul>
        </section>


        <section>
          <h2>Progress</h2>
          <img src="http://placekitten.com/g/500/300" alt="arch1">
          <aside class="notes" data-markdown>
            _John:_
            We had v1 of the API complete with endpoints for retrieving sighting data
            for a given species. The data set was so big that we were just using a partial
            import for development. Importing the whole set meant that query became
            less and less performant. It was time for me to go deep with my understanding of
            Datomic.

            Meanwhile, Chandu had some success spiking out a dynamic map so he decided
            to start working on the client-side. Let's take a look at his solution.
          </aside>
        </section>


        <section>
          <section>
            <h2>Displaying the Data</h2>
            <img src="images/geojson.png">
            <aside class="notes" data-markdown>
              * Set of libraries that enable DOM manipulation based on data
              bindings
              * Fluent API around using functional transforms of the bound data
              to change the state of the DOM elements

              We'll quickly cover the parts relating to mapping. d3 understands
              2 kinds of mapping data: GeoJSON and TopoJSON.

              GeoJSON is a subset of JSON that encodes geographic data. Using
              shapefiles generated from GIS mapping software, it represents
              geometries as connected arcs. d3 can take these arcs and plot
              SVG paths in the browser, complete with projections.

              TopoJSON is a form of GeoJSON specific to topologies, meaning that
              the arcs are aware of "inside" and "outside", and can eliminate
              redundant arcs between adjacent geometries (such as state
              borders).  TopoJSON payloads can be upto 80% smaller than GeoJSON
              for the same amount of information. We used TopoJSON which
              contained each county's name and state name bound to the geometry
              to uniquely identify each county.

              By normalizing the API to use the same key for each county as the
              SVG, we were able to associate the county-wise sighting data with
              the map, and as it changed month-to-month, d3 would transition the
              elements' colors accordingly.
            </aside>
          </section>

          <section>
            <h2>Displaying the Data</h2>
            <h4>Got ClojureScript?</h4>
            <p>Immediate wins:</p>
            <ul class="task-list">
              <li class="fragment">Easy to integrate into the existing stack</li>
              <li class="fragment">Same language on both client and server</li>
              <li class="fragment">Interoperability with JavaScript</li>
            </ul>
            <aside class="notes" data-markdown>
              ClojureScript seemed like an easy choice, given that we had a few
              immediate wins:

              As we began using more of it, its value became more apparent.
              Initially, though, it took a little getting used to.
            </aside>
          </section>

          <section>
            <h2>What is ClojureScript?</h2>
            <h3>Well, what <strong>is</strong> it, precious?</h3>
            <img width="60%" src="/images/gollum.gif" alt="What is it?">
            <aside class="notes" data-markdown>
              When you ask most people what ClojureScript is, this is the
              reaction you seem to get. In the world of JavaScript dev, it's
              not very clear where ClojureScript fits in. It's not a
              framework, or syntactic sugar on top of JavaScript.
              So what is it? It's a program that compiles Clojure into
              JavaScript.
            </aside>
          </section>

          <section>
            <h2>What is ClojureScript?</h2>
            <ul class="task-list">
              <li>Compiler for Clojure to JavaScript</li>
              <li class="fragment">Emits JS optimized for the Google Closure library</li>
              <li class="fragment">Several benefits over vanilla JS</li>
              <ul class="fragment">
                <li>Persistent data structures</li>
                <li>Object keys as opposed to only strings</li>
                <li>Laziness</li>
                <li>Macros</li>
                <li>Function argument destructuring</li>
              </ul>
            </ul>
            <aside class="notes" data-markdown>
              ### Compiler
              * cljsbuild plugin for Leiningen

              ### Closure
              * Minification
              * Namespacing modules
              * Dead code elimination

              ### Benefits
              These benefits have been spoken about in detail in other talks, and
              we have resources at the end which list some of them. It's really
              interesting work, and has come a long way since the initial thought
              experiment.

              So, the next step was to get d3 working with ClojureScript.
            </aside>
          </section>

          <section>
            <h2>ClojureScript and JavaScript Interop</h2>
            <h3>Methods</h3>
            <pre><code>
// JavaScript

var activeState = function() {
  return d3.select(".active");
}
            </code></pre>
            <pre><code>
;; ClojureScript

(defn active-state [] (.select js/d3 ".active"))
            </code></pre>
          </section>

          <section>
            <h2>ClojureScript and JavaScript Interop</h2>
            <h3>Properties</h3>
            <pre><code>
// JavaScript

var target = function() {
  return d3.event.target;
}
            </code></pre>
            <pre><code>
;; ClojureScript

(defn target [] (.-target (.-event js/d3)))
;; OR
(defn target [] (.. js/d3 -event -target)
            </code></pre>
          </section>

          <section>
            <h2>ClojureScript and JavaScript Interop</h2>
            <h3>Fluent APIs and the <code>-></code> Macro</h3>
            <pre><code>
// JavaScript

var months = d3.time.scale
               .domain([new Date(2012,10,15), new Date(2013,10,15)])
               .range([0, 900])
            </code></pre>
            <pre><code>
;; ClojureScript

(def months ( -&gt; (js/d3.time.scale)
   (.domain (array (js/Date. 2012 10 15) (js/Date. 2013 10 15)))
   (.range (array 0 900))))
            </code></pre>
          </section>
        </section>


        <section>
          <section>
            <h2>Progress</h2>
            <img src="http://placekitten.com/g/500/300" alt="arch2">
          </section>

          <section>
            <h2>We Have a Prototype! But...</h2>
            <ul class="fragment">
              <li>Unpolished UI</li>
              <li>No structure to the data</li>
              <li>The database query was slow</li>
              <li>Differing views of end result</li>
            </ul>
            <aside class="notes" data-markdown>
              _Chandu:_

              The fact that d3 could do DOM manipulation and event-handling let
              us build a prototype UI rather quickly by using d3 for both the
              mapping as well as the other interactive parts of the app, such
              as the bird and month selectors.

              I felt like we were done. We had a working version, lots of
              material for write-ups, some good insights. For me, ClojureScript
              was still just a means to get d3 working, nothing more. But John
              had other ideas!

              _John:_

              * Datomic improvements
              ** combination of splitting into species and sighting entities
              ** and partitioning the sightings by species
              * Achieved acceptable performance
              * Looking for other ways to contribute.
              * About that time there was a ton of exciting news happening in the
                clojurescript channels about a new library for front-end development.
              * Dude, Om is the new hotness.
            </aside>
          </section>
        </section>


        <section>
          <section>
            <h2>React and Om</h2>
            <h4>Imagination Land</h4>
            <img class="fragment" width="80%" src="images/wonka.gif">
            <aside class="notes" data-markdown>
              _John:_
              What Chandu did with D3 and the interactive maps is amazing and D3
              is a super powerful library for creating visualizations but when
              it came time to create the controls for our application we were
              frustrated by the same thing we're always frustrated by namely the
              scattering around of state and the growing complexity of dealing
              with events and coordination of state.

              We wondered what a functional approach to UIs would look like. [Next Slide]

              * Pretend you don't know anything about the DOM or browser enfironment
              * Unlearn the last 15 years of experience you have manipulating the DOM
              * Picture an ideal world where the DOM is just a function of your program state
            </aside>
          </section>

          <section>
            <h2>An Om Component</h2>
            <video height="500" controls>
              <source src="images/birdwave-filter-list.mp4" type="video/mp4">
            </video>

            <aside class="notes" data-markdown>
              * Here you can see a list of bird species
              * The user can type into the search box to filter the list
              * Up and down arrows to highlight and enter to select
              * Here we'll just focus on the filtering functionality
            </aside>
          </section>

          <section>
            <h2>Initial Render</h2>
            <h3>Remember: Imagination Land</h3>
            <pre>
;; ClojureScript
              <code>
(ul {:className "species-list"}
  (li {:className "species"} (a {:href "#/taxon/1"} "Abert's Towhee"))
  (li {:className "species"} (a {:href "#/taxon/2"} "Acadian Flycatcher"))
  (li {:className "species"} (a {:href "#/taxon/3"} "Acorn Woodpecker"))
  ... )
              </code>
            </pre>
          </section>

          <section>
            <h2>Building the List</h2>
            <pre>
;; ClojureScript
              <code>
(defn species-li [species]
  (li {:className "species"}
      (a {:href (path species)} (:common-name species))))

(map species-li all-species)
              </code>
            </pre>
            <aside class="notes">
              In imagination land the most straightforward way to render this list is to
              iterate over our data, building up our list as we go. Then when the list is built
              we replace old dom with our new representation. And our job is done.

              Note that this code doesn't mutate the DOM directly. It returns a datastructure
              that we can then ask the browser to paint for us. This makes testing our
              view code easy.
            </aside>
          </section>

          <section>
            <h2>Interactivity</h2>
            <pre>
;; ClojureScript
              <code>
(map species-li
     (filter (match-string "black-thr") species))
              </code>
            </pre>
            <aside class="notes">
              User types in some filter text. On each keystroke we match against the list.
            </aside>
          </section>

          <section>
            <h2>Putting It Together</h2>
            <pre>
;; ClojureScript
              <code>
(defn filter-list-items [filter-text species]
  (ul {:className "species-list"}
      (map species-li
           (filter (match-string filter-text) species))))

              </code>
            </pre>
          </section>

          <section>
            <h2>We Don't Live in Imagination Land</h2>
            <ul>
              <li>Replacing entire swaths of dom is slow</li>
              <li>No data structures</li>
              <li>Nobody does this in real life</li>
            </ul>
          </section>

          <section>
            <h2>React: A Better DOM</h2>
            <ul>
              <li>Render the dom you want</li>
              <li>React takes care of the details</li>
              <li>Keeps real DOM in sync with your ideal DOM</li>
            </ul>
          </section>

          <section>
            <h2>Om</h2>
            <ul>
              <li>Builds upon react</li>
              <li>Leverages immutability</li>
            </ul>
          </section>

          <section>
            <h2>Om Example</h2>
            <pre>
;; ClojureScript
              <code>
(defn selection-name [name owner]
  (om/component
    (dom/h2 #js {:className "selection-name"} name)))
              </code>
            </pre>
          </section>

          <section>
            <h2>Handling Events In Om</h2>
            <pre>
;; ClojureScript
              <code>

(defn date-minus [model owner]
  (om/component
    (dom/span #js {:id "date-minus"
                   :onClick #(update-month! model owner dec)}
              "-")))
              </code>
            </pre>
          </section>
        </section>


        <section>
          <section>
            <h2>Brainsplosion</h2>
            <img width="80%" src="images/brainsplosion.gif">
            <aside class="notes" data-markdown>
              _Chandu:_
              It took me a little while to warm up to Om and React. In the
              beginning, it seemed like needless complexity as compared to what
              I was used to with say something like Angular, which would just
              bind to whatever state you already had.

              But as I began to understand that I didn't need to care about
              the component's view state, only the data it needed, I began to
              see the simplicity of the approach. I wanted to try building a
              component, and the perfect opportunity presented itself.
            </aside>
          </section>

          <section>
            <h2>Integrating With Flickr</h2>
            <img height="240" src="images/flickr-img.png">
            <img height="240" src="images/flickr-hover1.png">
            <img height="240" src="images/flickr-hover2.png">
            <aside class="notes" data-markdown>
              One of the feature requests for Birdwave was to show a photo of
              the selected bird where possible. I needed a service that could
              take the bird name, search Flickr for images with a CC license
              and return the first one. What I didn't need was a giant Flickr
              library, just something simple that could build (as it turned
              out) 2 API requests.
            </aside>
          </section>

          <section>
            <h2>Integrating With Flickr</h2>
            <pre><code>
;; ClojureScript
(ns bird-wave.flickr (:require [cemerick.url :refer (url)]))

(def api-base-url (url "https://api.flickr.com/services/rest/"))
;;#cemerick.url.URL{:protocol "http", :username nil, :password nil, :host "google.com", :port -1, :path "", :query nil, :anchor nil}

(str (assoc api-base-url :query {:api_key "my_super_flickr_key"}))
;; https://api.flickr.com/services/rest/?api_key=my_super_flickr_key
            </code></pre>
            <aside class="notes" data-markdown>
            Here's a simple example of what ClojureScript allowed me to do:
            * Query string can contain: api_key, nojsoncallback, license, search
            * The `url` library allows me to take a string and create a URL instance
            * I can associate a map of key values to this instance
            * When I call `str` on it, it creates a query string with the map
            * It made creating the long Flickr API strings a breeze
            </aside>
          </section>

          <section>
            <h2>Integrating With Flickr</h2>
            <h4>Updating the Model</h4>
            <pre><code>
;; ClojureScript

(js/d3.json search-url (fn [data]
  (om/update! model :photo (first-photo data))))
;; { "photos": { "page": 1, "pages": "223", "perpage": 1, "total": "223",
;;  "photo": [
;;    { "id": "4769690133", "owner": "31064702@N05", "secret": "818406d0cd", "server": "4123", "farm": 5, "title": "Eastern Kingbird", "ispublic": 1, "isfriend": 0, "isfamily": 0, "ownername": "Dawn Huczek", "url_q": "https:\/\/farm5.staticflickr.com\/4123\/4769690133_818406d0cd_q.jpg", "height_q": "150", "width_q": "150" }
;;  ] }, "stat": "ok" }

(js/d3.json url (fn [data]
  (om/update! model :attribution (attribution data))))
;; { "photo": { "id": "4769690133", "secret": "818406d0cd", "server": "4123", "farm": 5, "dateuploaded": "1278473496", "isfavorite": 0, "license": 4, "safety_level": 0, "rotation": 0, "originalsecret": "d7072dbb9a", "originalformat": "jpg",
;; "owner": { "nsid": "31064702@N05", "username": "Dawn Huczek", "realname": "", "location": "USA", "iconserver": "2915", "iconfarm": 3, "path_alias": "" },
;; ...
;; "urls": {
;;   "url": [
;;     { "type": "photopage", "_content": "https:\/\/www.flickr.com\/photos\/31064702@N05\/4769690133\/" }
;;   ] }, "media": "photo" }, "stat": "ok" }
            </code></pre>
            <aside class="notes" data-markdown>
              When a user selects a bird, we make the first request.
              `search-url` is the Flickr url we need to hit. The json we get
              back is shown under. The `first-photo` function extracts the
              nested photo info.

              When a user clicks the "view attribution" link, we make the
              second request, and fetch the json under that. The `attribution`
              function pulls out the username and link to the Flickr photo
              page.
            </aside>
          </section>

          <section>
            <h2>Integrating With Flickr</h2>
            <h4>The Selection Image Component</h4>
            <pre><code>
;; ClojureScript
(dom/div #js {:id "selection-image"
              :className (if (seq model) "loaded" "no-photo")}
   (dom/img #js {:className "photo"
                 :src (try-with-default model :url_q "/images/loading.png")})
   (dom/div #js {:className "attribution"}
     (dom/h3 #js {:className "title"}
       (try-with-default model :title "No photo available"))
     (dom/div #js {:className "by"}
       &hellip;
       (if (seq (:attribution model))
         (dom/a #js {:className "detail fetched"
                     :href (get-in model [:attribution :url])
                     :target "_blank"}
                (get-in model [:attribution :by]))
         (dom/a #js {:className "detail"
                     :href "#"
                     :onClick #(fetch-attribution % model)}
                "view attribution")))))
            </code></pre>
          </section>
        </section>


        <section>
          <h2>Progress</h2>
          <img src="http://placekitten.com/g/500/300" alt="arch3">
        </section>


        <section>
          <h2>Making the App Responsive</h2>
          <h4>Full-stack changes</h4>
          <img src="http://placekitten.com/g/400/300" alt="enquire-related slides">
        </section>


        <section>
          <section>
            <h2>Lessons and Insights</h2>
            <img src="images/gollum-finds.gif" width="80%">
          </section>

          <section>
            <h2>Lessons and Insights</h2>
            <h3>Immutability is good!</h3>
            <ul>
              <li>Om is more efficient than React ootb</li>
              <li>Avoids lots of potential JS bugs</li>
            </ul>
          </section>

          <section>
            <h2>Lessons and Insights</h2>
            <h3>ClojureScript has come a long way</h3>
            <ul>
              <li>Debugging with source maps</li>
              <li>JS interop is painless</li>
              <li>The build process is automated</li>
            </ul>
          </section>
        </section>


        <section>
          <section data-markdown>
            ## Resources
            #### Birding
            * [eBird.org](http://ebird.org)
            * [Cornell Lab of Ornithology](http://birds.cornell.edu)
          </section>

          <section data-markdown>
            ## Resources
            #### Clojure
            * [clojure.org](http://clojure.org)
          </section>

          <section data-markdown>
            ## Resources
            #### ClojureScript
            * [The ClojureScript Compilation Pipeline](http://blog.fogus.me/2012/04/25/the-clojurescript-compilation-pipeline/)
          </section>

          <section data-markdown>
            ## Resources
            #### d3
          </section>

          <section data-markdown>
            ## Resources
            #### Birdwave
            * [Announcing Birdwave](http://www.neo.com/2014/09/22/announcing-birdwave)
            * [Choropleths and d3js](http://www.neo.com/2014/04/21/choropleths-and-d3js)
            * [Using the Flickr API with ClojureScript](http://www.neo.com/2014/07/18/using-the-flickr-api-with-clojurescript)
            * [Adding an Om Component -- a Walkthrough](http://www.neo.com/2014/11/17/adding-a-clojurescriptom-component-a-walkthrough)
            * [Responsive JavaScript with EnquireJS](http://www.neo.com/2014/10/03/responsive-javascript-with-enquirejs)
          </section>
        </section>
      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.min.js"></script>

    <script>

      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        theme: "neo", // available themes are in /css/theme
        transition: "linear", // default/cube/page/concave/zoom/linear/fade/none

        // Parallax scrolling
        // parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
        // parallaxBackgroundSize: '2100px 900px',

        // Optional libraries used to extend on reveal.js
        dependencies: [
        { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
        { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
        { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
        { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
        { src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
        { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
        // , { src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
        ]
        });

      </script>

    </body>
  </html>
