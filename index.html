<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="description" content="Slides for the CodeMash 2015 talk by Chandu Tennety and John Andrews">
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>A Bird's Eye View of ClojureScript</title>
    <link rel="stylesheet" href="css/reveal.min.css">
    <link rel="stylesheet" href="css/theme/solarized.css" id="theme">
    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="lib/css/hemisu-light.css">
    <!-- If the query includes 'print-pdf', include the PDF print sheet -->
    <script>
      if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = 'css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
      }
    </script>
    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <h1>A Bird's Eye View of ClojureScript</h1>
          <h3>Or: you don't <em>have</em> to write JavaScript!</h3>
          <p>
            <small>Chandu Tennety &middot; John Andrews</small>
          </p>
          <aside class="notes">
            Thank you for coming to this talk, we value your time and are excited that you chose to share it with us.
            And we're excited to share our experiences with you and hope that you find value from them.
            I'm Chandu, I do app development at Neo, mostly using Rails and JavaScript. This is John Andrews.
            <!-- John introduces himself ><!-->
          </aside>
        </section>


        <section>
          <h2>Motivation</h2>
          <h3>Birding: a brief introduction</h3>
          <div class="fragment">
            <img alt="map" src="images/map.gif"><br>
            <small><a href="http://press.princeton.edu/birds/arlott/warbler/images/map.gif" target="_blank">Source: Princeton University</a></small>
          </div>
          <aside class="notes" data-markdown>
            The idea of Birdwave came to me partly because of an interest and a
            hobby that I have.
            ### Birding
            * Observing and identifying birds, visually and by ear.
            * Quiet and relaxing (when you need to get away from big crowds of technologists)
            * Closely tied with migratory patterns:
              - Migration seasons are peaks
              - Non-migratory birds are all you have in the off-season
            * Field guides
              - Beautiful illustrations, identifying characteristics
              - Show static maps of breeding areas during the year
              * So I thought it'd be nice to plot bird migration data on a map,
              as it changes month-to-month.
            * Basically this...
          </aside>
        </section>


        <section>
          <h2>Demo &mdash; Birdwave</h2>
          <video autoplay>
            <source src="images/birdwave-demo.mp4" type="video/mp4">
          </video>
        </section>


        <section>
          <section>
            <h2>Premise &mdash; Data</h2>
            <h3><a target="_blank" href="http://ebird.org/content/ebird/about/">eBird</a> data set</h3>
            <ul class="task-list">
              <li class="fragment">Data for 1 year for the US region</li>
              <li class="fragment">11 GB of tab-separated values</li>
              <li class="fragment">Over 1700 species</li>
            </ul>
            <aside class="notes" data-markdown>
              ### eBird
              * Collaboration between National Audubon Society and Cornell Lab of Ornithology
              * Gather bird sighting reports from all over the world (an incredible amount of data)
              * Have a very basic API, not good for trends
              * Data available for download free for academic use
            </aside>
          </section>

          <section>
            <h2>Premise &mdash; Back-end</h2>
            <h3>The need for an API</h3>
            <ul class="task-list">
              <li class="fragment">Too much data to load at once</li>
              <li class="fragment">Dynamic nature of the app</li>
              <li class="fragment">d3 handles JSON requests</li>
            </ul>
            <aside class="notes" data-markdown>
              * There's way too much data to *not* load on demand
              * The event-driven nature of the app meant that it couldn't be
              modeled with a traditional request-response cycle. There needed to
              be an API capable of rendering tailored responses to different
              parameters.
              That's when John and Chris Westra decided to use Clojure to build
              this API.
            </aside>
          </section>
        </section>


        <section>
          <h2>Why Clojure</h2>
            <pre>
;; Clojure
            <code>
(defn sighting-seq
  "Return a lazy sequence of lines from filename, transformed into sighting maps"
  [filename skip-rows nth-row]
  (map sighting
    (take-nth nth-row
      (drop (if skip-rows skip-rows 1)
        (line-seq (io/reader filename))))))
          </code></pre>
        </section>


        <section>
          <h2>Premise &mdash; Front-end</h2>
          <h3>Got ClojureScript?</h3>
          <p>Immediate wins:</p>
          <ul class="task-list">
            <li class="fragment">Easy to integrate into the existing stack</li>
            <li class="fragment">Same language on both client and server</li>
            <li class="fragment">Interoperability with JavaScript</li>
          </ul>
          <aside class="notes" data-markdown>
            Now that we had a functioning API, we had to go back and take a
            look at how to build the front-end. ClojureScript seemed like an
            easy choice, given that we had a few immediate wins:

            As we began using more of it, its value became more apparent.
            Initially, though, it took a little getting used to.
          </aside>
        </section>


        <section>
          <section>
            <h2>Why ClojureScript?</h2>
            <h3>Well, what <strong>is</strong> it, precious?</h3>
            <img src="/images/gollum.gif" alt="What is it?">
            <aside class="notes" data-markdown>
              When you ask most people what ClojureScript is, this is the
              reaction you seem to get. In the world of JavaScript dev, it's
              not very clear where ClojureScript fits in. It's not a
              framework, or syntactic sugar on top of JavaScript.
              So what is it? It's a program that compiles Clojure into
              JavaScript.
            </aside>
          </section>

          <section>
            <h2>Why ClojureScript?</h2>
            <ul class="task-list">
              <li>Compiler for Clojure to JavaScript</li>
              <li class="fragment">Emits JS optimized for the Google Closure library</li>
              <li class="fragment">Several benefits over vanilla JS</li>
              <ul class="fragment">
                <li>Persistent data structures</li>
                <li>Object keys as opposed to only strings</li>
                <li>Macros</li>
                <li>Function argument destructuring</li>
              </ul>
            </ul>
            <aside class="notes" data-markdown>
              ### Compiler
              * cljsbuild plugin for Leiningen

              ### Closure
              * Minification
              * Namespacing modules
              * Dead code elimination

              ### Benefits
              These benefits have been spoken about in detail in other talks, and
              we have resources at the end which list some of them. It's really
              interesting work, and has come a long way since the initial thought
              experiment.
            </aside>
          </section>

          <section>
            <h2>Why ClojureScript?</h2>
            <h3>A Small Example:</h3>
            <pre>
;; ClojureScript
            <code>
(ns bird-wave.flickr (:require [cemerick.url :refer (url)]))

(def api-base-url (url "https://api.flickr.com/services/rest/"))
;;#cemerick.url.URL{:protocol "http", :username nil, :password nil, :host "google.com", :port -1, :path "", :query nil, :anchor nil}

(str (assoc api-base-url :query {:api_key "my_super_flickr_key"}))
;; https://api.flickr.com/services/rest/?api_key=my_super_flickr_key
            </code></pre>
            <aside class="notes" data-markdown>
            Here's a simple example of what ClojureScript allows me to do. Say
            you're building a Flickr API client.
            * Query string can contain: api_key, nojsoncallback, license, search
            * The `url` library allows me to take a string and create a URL instance
            * I can associate a map of key values to this instance
            * When I call `str` on it, it creates a query string with the map
            * It made creating the long Flickr API strings a breeze

            That was a simple example. On a much more advanced level, there
            are libraries available in Clojureland the likes of which are
            pretty hard to find in the JS ecosystem. Here's one example that
            John's going to talk about:
            </aside>
          </section>

          <section>
            <h2>Why ClojureScript?</h2>
            <h6>Two (dot-separated) words:</h6>
            <h3 class="fragment"><code>core.async</code></h3>
            <aside class="notes" data-markdown>
              * powerful channel-based asynchronous programming
              * similar to goroutines from golang
              * turns async code into sync-looking code
            </aside>
          </section>

          <section>
            <h2>core.async example</h2>
            <pre>
;; ClojureScript
              <code>
(go
  (alt!
    (await-taxonomy model)
    (log "Located " (count model) " records")

    (timeout 60000)
    (log "Timed out waiting for data")))
              </code>
            </pre>

            <aside class="notes" data-markdown>
              * alt! is like switch for channels
              * takes the first message from any channel
              * timeout is builtin to core async
              * how do we create await-taxonomy
            </aside>
          </section>

          <section>
            <h2>core.async</h2>
            <pre>
;; ClojureScript
              <code>
(defn await-taxonomy
  "Return a channel which will receive the value of
   :taxonomy after it has a non-empty value"
  [model]
  (go-loop [{:keys [taxonomy]} (deref model)]
    (if (not-empty taxonomy)
      taxonomy
      (do (<! (timeout 10))
          (recur (deref model))))))
              </code>
            </pre>
            <aside class="notes" data-markdown>
              * returns a channel
              * destructures model to retrieve taxonomy
              * loops until non-nil taxonomy
              * no callbacks
            </aside>
          </section>
        </section>


        <section>
          <h2>Mapping with d3</h2>
          <h3>GeoJSON and TopoJSON</h3>
          <img src="images/geojson.png">
          <aside class="notes" data-markdown>
            After that mind-trip, let's shift gears and talk about d3.
            * Set of libraries that enable DOM manipulation based on data
            bindings
            * Fluent API around using functional transforms of the bound data
            to change the state of the DOM elements

            We'll quickly cover the parts relating to mapping. d3 understands
            2 kinds of mapping data: GeoJSON and TopoJSON.

            GeoJSON is a subset of JSON that encodes geographic data. Using
            shapefiles generated from GIS mapping software, it represents
            geometries as connected arcs. d3 can take these arcs and plot
            SVG paths in the browser, complete with projections.

            TopoJSON is a form of GeoJSON specific to topologies, meaning that
            the arcs are aware of "inside" and "outside", and can eliminate
            redundant arcs between adjacent geometries (such as state
            borders).  TopoJSON payloads can be upto 80% smaller than GeoJSON
            for the same amount of information. We used TopoJSON which
            contained each county's name and state name bound to the geometry
            to uniquely identify each county.

            By normalizing the API to use the same key for each county as the
            SVG, we were able to associate the county-wise sighting data with
            the map, and as it changed month-to-month, d3 would transition the
            elements' colors accordingly.

            So how did we get d3 working with ClojureScript?
          </aside>
        </section>


        <section>
          <section>
            <h2>d3 and JavaScript Interop</h2>
            <h3>Methods and Props</h3>
            <pre>
// JavaScript
            <code>
var activeState = function() {
  return d3.select(".active");
}
            </code></pre>
            <pre>
;; ClojureScript
            <code>
(defn active-state [] (.select js/d3 ".active"))
            </code></pre>
          </section>

          <section>
            <h2>d3 and JavaScript Interop</h2>
            <h3>Methods and Props</h3>
            <pre>
// JavaScript
            <code>
var target = function() {
  return d3.event.target;
}
            </code></pre>
            <pre>
;; ClojureScript
            <code>
(defn target [] (.-target (.-event js/d3)))
            </code></pre>
          </section>

          <section>
            <h2>d3 and JavaScript Interop</h2>
            <h3>Fluent APIs and the <code>-></code> Macro</h3>
            <pre>
// JavaScript
            <code>
var months = d3.time.scale
               .domain([new Date(2012,10,15), new Date(2013,10,15)])
               .range([0, 900])
            </code></pre>
            <pre>
;; ClojureScript
            <code>
(def months ( -> (js/d3.time.scale)
   (.domain (array (js/Date. 2012 10 15) (js/Date. 2013 10 15)))
   (.range (array 0 900))))
            </code></pre>
            <aside class="notes" data-markdown>
              _Chandu:_
              The fact that d3 could do DOM manipulation and event-handling let
              us build a prototype UI rather quickly by using d3 for not just
              the mapping but also for other interactive parts of the app, such
              as the bird and month selectors. But I took it too far.  That's
              when John stepped in with Om.
            </aside>
          </section>
        </section>


        <section>
          <section>
            <h2>Richer UI with React and Om</h2>
            <aside class="notes" data-markdown>
              _John:_
              What Chandu did with D3 and the interactive maps is amazing and D3
              is a super powerful library for creating visualizations but when
              it came time to create the controls for our application we were
              frustrated by the same thing we're always frustrated by namely the
              scattering around of state and the growing complexity of dealing
              with events and coordination of state.

              We wondered what a functional approach to UIs would look like.
            </aside>
          </section>

          <section>
            <h2>Imagination Land</h2>
            <img src="images/wonka.gif">
            <aside class="notes" data-markdown>
              _John:_
              * Pretend you don't know anything about the DOM or browser enfironment
              * Unlearn the last 15 years of experience you have manipulating the DOM
              * Picture an ideal world where the DOM is just a function of your program state
            </aside>
          </section>

          <section>
            <h2>A Component</h2>
            <video autoplay>
              <source src="images/birdwave-filter-list.mp4" type="video/mp4">
            </video>
          </section>

          <section>
            <h2>Initial Render</h2>
            <h3>Remember: Imagination Land</h3>
            <pre>
;; ClojureScript
              <code>
(ul {:className "species-list"}
  (li {:className "species"} (a {:href "#/taxon/1"} "Abert's Towhee"))
  (li {:className "species"} (a {:href "#/taxon/2"} "Acadian Flycatcher"))
  (li {:className "species"} (a {:href "#/taxon/3"} "Acorn Woodpecker"))
  ... )
              </code>
            </pre>
          </section>

          <section>
            <h2>Building the list</h2>
            <pre>
;; ClojureScript
              <code>
(defn species-li [species]
  (li {:className "species"}
      (a {:href (path species)} (:common-name species))))

(map species-li all-species)
              </code>
            </pre>
            <aside class="notes">
              In imagination land the most straightforward way to render this list is to
              iterate over our data, building up our list as we go. Then when the list is built
              we replace old dom with our new representation. And our job is done.

              Note that this code doesn't mutate the DOM directly. It returns a datastructure
              that we can then ask the browser to paint for us. This makes testing our
              view code easy.
            </aside>
          </section>

          <section>
            <h2>Interactivity</h2>
            <pre>
;; ClojureScript
              <code>
(map species-li
     (filter (match-string "black-thr") species))
              </code>
            </pre>
            <aside class="notes">
              User types in some filter text. On each keystroke we match against the list.
            </aside>
          </section>

          <section>
            <h2>Putting it together</h2>
            <pre>
;; ClojureScript
              <code>
(defn filter-list-items [filter-text species]
  (ul {:className "species-list"}
      (map species-li
           (filter (match-string filter-text) species))))

              </code>
            </pre>
          </section>

          <section>
            <h2>We don't live in imagination land</h2>
            <ul>
              <li>Replacing entire swaths of dom is slow</li>
              <li>No data structures</li>
              <li>Nobody does this in real life</li>
            </ul>
          </section>

          <section>
            <h2>React: A better DOM</h2>
            <ul>
              <li>Render the dom you want</li>
              <li>React takes care of the details</li>
              <li>Keeps real DOM in sync with your ideal DOM</li>
            </ul>
          </section>

          <section>
            <h2>Om</h2>
            <ul>
              <li>Builds upon react</li>
              <li>Leverages immutability</li>
            </ul>
          </section>

          <section>
            <h2>Om Example</h2>
            <pre>
;; ClojureScript
              <code>
(defn selection-name [name owner]
  (om/component
    (dom/h2 #js {:className "selection-name"} name)))
              </code>
            </pre>
          </section>

          <section>
            <h2>Handling Events In Om</h2>
            <pre>
;; ClojureScript
              <code>

(defn date-minus [model owner]
  (om/component
    (dom/span #js {:id "date-minus"
                   :onClick #(update-month! model owner dec)}
              "-")))
              </code>
            </pre>
          </section>
        </section>


        <section>
          <section data-markdown>
            ## Resources
            #### Birding
            * [eBird.org](http://ebird.org)
            * [Cornell Lab of Ornithology](http://birds.cornell.edu)
          </section>

          <section data-markdown>
            ## Resources
            #### Clojure
            * [clojure.org](http://clojure.org)
          </section>

          <section data-markdown>
            ## Resources
            #### ClojureScript
          </section>

          <section data-markdown>
            ## Resources
            #### d3
          </section>
        </section>
      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.min.js"></script>

    <script>

      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        theme: "solarized", // available themes are in /css/theme
        transition: "page", // default/cube/page/concave/zoom/linear/fade/none

        // Parallax scrolling
        // parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
        // parallaxBackgroundSize: '2100px 900px',

        // Optional libraries used to extend on reveal.js
        dependencies: [
        { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
        { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
        { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
        { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
        { src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
        { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
        // , { src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
        ]
        });

      </script>

    </body>
  </html>
